# AutoML-driven Algorithmic Trading System

Это высокоуровневая AutoML-подобная среда для генеративного поиска, тестирования и оптимизации торговых стратегий. Система разделена на два ключевых компонента: "Инструментарий" (низкоуровневые исполнители) и "Конструкторское Бюро" (высокоуровневый оркестратор).

# Архитектура
##"Инструментарий" (Проект 1)

Набор атомарных, параметризуемых классов-исполнителей, каждый из которых отвечает за одну конкретную задачу в пайплайне:

    **FeatureEngineer**: Генерация признаков.

    **DataLabeler**: Разметка данных (создание целевой переменной).

    **DataSplitter**: Разделение и нормализация выборок.

    **ModelTrainer**: Обучение ML-модели.

    **Backtester**: Проведение финансового бэктеста.

    **Inferencer**: "Боевое" применение модели.
    

## "Конструкторское Бюро" (Проект 2)

Система-оркестратор, которая управляет "Инструментарием" для проведения экспериментов.

    **Конфигурация**: Эксперименты описываются с помощью YAML-файлов.

    **Оптимизация**: Для поиска оптимальных гиперпараметров используется Optuna.

    **Логирование**: Все запуски, параметры и метрики отслеживаются с помощью MLflow.

    **Точка входа**: Управление системой осуществляется через единый скрипт manage.py.
    

# Быстрый старт
##1. Установка
   
### Создать и активировать окружение

`python -m venv venv

`source venv/bin/activate  # Для Windows: .\venv\Scripts\activate

### Установить зависимости

`pip install optuna mlflow pandas numpy scikit-learn pyyaml

##2. Данные

###    Создайте папку data в корне проекта.

###    Поместите в нее CSV-файл с котировками, например EURUSD_D.csv.

##3. Запуск
    
### Запустить поиск на 5 итераций, используя готовый конфиг

`python manage.py search --config configs/test_search.yaml --n-trials 5

### Запустить UI для просмотра результатов

`python manage.py ui

##Откройте в браузере http://127.0.0.1:5000.


#Минимально необходимая реализация

Для того чтобы цикл поиска manage.py search отработал без ошибок, необходимо реализовать run() методы в следующих классах-заглушках. Оркестратор ожидает от них возврата данных строго определенного формата.

    **FeatureEngineer**: Должен вернуть pd.DataFrame с признаками.

    **DataLabeler**: Должен вернуть pd.DataFrame со столбцом target.

    **DataSplitter**: Должен вернуть кортеж из трех pd.DataFrame: (train, val, test).

    **ModelTrainer**: Должен вернуть dict с ML-метриками (например, {'accuracy': 0.5}).

    **Backtester**: (Обязателен). Должен вернуть dict с финансовыми метриками. Критически важно: словарь должен содержать ключ, который оптимизирует Optuna (по умолчанию sharpe_ratio). Пример: {'sharpe_ratio': 1.0}.

#Архитектура автоматизированного поиска (manage.py search)

##### [manage.py] (Точка входа CLI)
##### └── "search"
#####     └── [SearchOrchestrator] (Управляет всем процессом поиска)
#####         ├── Optuna           (Подкомпонент: генерирует параметры для каждого эксперимента)
#####         ├── MLflow           (Подкомпонент: логирует все результаты)
#####         │
#####         └── [ExperimentRunner] (Исполняет ОДИН конкретный эксперимент/trial)
#####             │
#####             ├─> [DataPreparer]   (Шаг 1: Подготовка данных)
#####             │    ├── FeatureEngineer
#####             │    ├── DataLabeler
#####             │    └── DataSplitter
#####             │
#####             ├─> [ModelTrainer]   (Шаг 2: Обучение модели)
#####             │
#####             └─> [Backtester]     (Шаг 3: Финансовый бэктест)
